# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ET2QGIS
                     A QGIS plugin
 This plugin creates analyses and visualizations from ET2Spatial data.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                  -------------------
     begin                : 2023-08-02
     git sha              : $Format:%H$
     copyright            : (C) 2023 by Tomas Vanicek (Palacky University)
     email                : tomas.vanicek@upol.cz
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
# IMPORT OF LIBRARIES
from qgis.PyQt.QtCore import *
from qgis.PyQt.QtWidgets import *
from qgis.PyQt.QtGui import *
from qgis.utils import *
from qgis.core import *
from PyQt5.QtCore import *
from PyQt5.QtWidgets import *
from osgeo import ogr
import os, shutil, geopandas as gpd
import pandas as pd
from .resources import *
from .et2qgis_dockwidget import *
from random import randint
import random
import math
import matplotlib.pyplot as plt
import glob
import traceback

# METHODS NECESSARY FOR THE LIFE OF THE PLUGIN
class ET2QGIS:
    def __init__(self, iface):
        self.iface = iface
        self.plugin_dir = os.path.dirname(__file__)
        locale = QSettings().value('locale/userLocale')[0:2] 
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'ET2QGIS_{}.qm'.format(locale))
        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        self.actions = []
        self.menu = self.tr(u'&ET2QGIS')
        self.toolbar = self.iface.addToolBar(u'ET2QGIS')
        self.toolbar.setObjectName(u'ET2QGIS')

        self.pluginIsActive = False
        self.dockwidget = None
        self.selected_layers = []
        self.selected_AOI_layers = []
    def tr(self, message):
        return QCoreApplication.translate('ET2QGIS', message)
    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)
        if status_tip is not None: 
            action.setStatusTip(status_tip)
        if whats_this is not None: 
            action.setWhatsThis(whats_this)
        if add_to_toolbar:
            self.toolbar.addAction(action)
        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)
        self.actions.append(action)
        return action
    def initGui(self):
        icon_path = ':/plugins/et2qgis/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'ET2QGIS'),
            callback=self.run,
            parent=self.iface.mainWindow())
    def onClosePlugin(self):
        self.dockwidget.closingPlugin.disconnect(self.onClosePlugin)
        self.pluginIsActive = False 
    def unload(self):
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&ET2QGIS'),
                action)
            self.iface.removeToolBarIcon(action)
        del self.toolbar  
 
# METHOD OF LOADING AND RUNNING PLUGINS
    def run(self):
        # Check if the plugin is currently active
        if not self.pluginIsActive:
            # Set the plugin's active status to True
            self.pluginIsActive = True

            # Check if the dockwidget is None
            if self.dockwidget is None:
                # Create a new instance of ET2QGISDockWidget
                self.dockwidget = ET2QGISDockWidget()

            # Connect the closingPlugin signal to the onClosePlugin method
            self.dockwidget.closingPlugin.connect(self.onClosePlugin)

            # Display the dockwidget
            self.dockwidget.show()

            # Connect the SelectOutputButton signal to the select_output_dir method
            self.dockwidget.SelectOutputButton.clicked.connect(self.select_output_dir)

            # Connect the AddFilesButton signal to the add_files method
            self.dockwidget.AddFilesButton.clicked.connect(self.add_files)

            # Connect the RemoveFilesButton signal to the remove_files method
            self.dockwidget.RemoveFilesButton.clicked.connect(self.remove_files)

            # Connect the RunButton signal to the start method
            self.dockwidget.RunButton.clicked.connect(self.start)

            # Connect the AddAOIButton signal to the add_AOI_polygons method
            self.dockwidget.AddAOIButton.clicked.connect(self.add_AOI_polygons)

           # Connect the RemoveAOIButton signal to the remove_AOI_files method
            self.dockwidget.RemoveAOIButton.clicked.connect(self.remove_AOI_files)

           # Connect the AOI_about signal to the AOI_about method
            self.dockwidget.AOI_about.clicked.connect(self.AOI_about)

           # Connect the AVD_about signal to the AVD_about method
            self.dockwidget.AVD_about.clicked.connect(self.AVD_about)  

            # Connect the Heatmap_about signal to the Heatmap_about method
            self.dockwidget.Heatmap_about.clicked.connect(self.Heatmap_about)

# THE OUTPUT DIRECTORY
    def select_output_dir(self):
        # Open a dialog to select a directory and assign the selected directory path to self.dirname
        self.dirname = QFileDialog.getExistingDirectory(
            self.dockwidget, "Select directory ", os.path.expanduser("~")
        )
        # Set the text of the SelectOutputWindow widget in the dockwidget to the selected directory path
        self.dockwidget.SelectOutputWindow.setText(self.dirname)
    def create_temp_dir(self):
        base_temp_dir_name = "ET2QGIS_temp"
        temp_dir_path = os.path.join(self.dirname, base_temp_dir_name)

        # Check and create a directory with an incremented suffix if one already exists
        count = 1
        while os.path.exists(temp_dir_path):
            temp_dir_path = os.path.join(self.dirname, f"{base_temp_dir_name}{count}")
            count += 1

        # Create the new directory
        os.makedirs(temp_dir_path)

        # Update the temp directory path
        self.temp = temp_dir_path
    def delete_temp_dir(self):
        base_temp_dir_name = "ET2QGIS_temp"
        count = 0

        # Attempt to remove all existing ET2QGIS_temp directories, except the most recent
        while True:
            temp_dir_suffix = str(count) if count > 0 else ''
            temp_dir_path = os.path.join(self.dirname, f"{base_temp_dir_name}{temp_dir_suffix}")

            if os.path.exists(temp_dir_path):
                if temp_dir_path != self.temp:  # Skip the most recent temp directory
                    try:
                        shutil.rmtree(temp_dir_path)
                    except Exception as e:
                        print(f"Could not delete {temp_dir_path}: {e}")
            else:
                if count > 0:
                    break  # Exit if the directory does not exist and count is non-zero

            count += 1
    def create_fix_dir(self):
        base_fix_dir_name = "ET2QGIS_fix"
        fix_dir_path = os.path.join(self.dirname, base_fix_dir_name)

        # Check and create a directory with an incremented suffix if one already exists
        count = 1
        while os.path.exists(fix_dir_path):
            fix_dir_path = os.path.join(self.dirname, f"{base_fix_dir_name}{count}")
            count += 1

        # Create the new directory
        os.makedirs(fix_dir_path)

        # Update the temp directory path
        self.fix_dir = fix_dir_path
    def create_raw_dir(self):
        base_raw_dir_name = "ET2QGIS_raw"
        raw_dir_path = os.path.join(self.dirname, base_raw_dir_name)

        # Check and create a directory with an incremented suffix if one already exists
        count = 1
        while os.path.exists(raw_dir_path):
            raw_dir_path = os.path.join(self.dirname, f"{base_raw_dir_name}{count}")
            count += 1

        # Create the new directory
        os.makedirs(raw_dir_path)

        # Update the temp directory path
        self.raw_dir = raw_dir_path
    def create_AOI_dir(self):
        base_AOI_dir_name = "ET2QGIS_AOI"
        AOI_dir_path = os.path.join(self.dirname, base_AOI_dir_name)

        # Check and create a directory with an incremented suffix if one already exists
        count = 1
        while os.path.exists(AOI_dir_path):
            AOI_dir_path = os.path.join(self.dirname, f"{base_AOI_dir_name}{count}")
            count += 1

        # Create the new directory
        os.makedirs(AOI_dir_path)

        # Update the temp directory path
        self.AOI_dir = AOI_dir_path
    def create_AVD_dir(self):
        base_AVD_dir_name = "ET2QGIS_AVD"
        AVD_dir_path = os.path.join(self.dirname, base_AVD_dir_name)

        # Check and create a directory with an incremented suffix if one already exists
        count = 1
        while os.path.exists(AVD_dir_path):
            AVD_dir_path = os.path.join(self.dirname, f"{base_AVD_dir_name}{count}")
            count += 1

        # Create the new directory
        os.makedirs(AVD_dir_path)

        # Update the temp directory path
        self.AVD_dir = AVD_dir_path
    def create_Heatmap_dir(self):
        base_Heatmap_dir_name = "ET2QGIS_Heatmap"
        Heatmap_dir_path = os.path.join(self.dirname, base_Heatmap_dir_name)

        # Check and create a directory with an incremented suffix if one already exists
        count = 1
        while os.path.exists(Heatmap_dir_path):
            Heatmap_dir_path = os.path.join(self.dirname, f"{base_Heatmap_dir_name}{count}")
            count += 1

        # Create the new directory
        os.makedirs(Heatmap_dir_path)

        # Update the temp directory path
        self.Heatmap_dir = Heatmap_dir_path

# BUTTON FOR ENTERING AND SELECTING INPUT FILES (QListViews)
    def add_files(self):
        # Create a file dialog instance
        file_dialog = QFileDialog()

        # Set the file mode to allow selecting multiple existing files
        file_dialog.setFileMode(QFileDialog.ExistingFiles)

        # Set the name filter to only show Shapefile files
        file_dialog.setNameFilter("ESRI Shapefile (*.shp)")

        # Execute the file dialog and check if it was accepted
        if file_dialog.exec_():
            # Get the list of selected files from the file dialog
            selected_files = file_dialog.selectedFiles()

            # Extend the list of selected layers with the selected files
            self.selected_layers.extend(selected_files)

            # Update the list view to reflect the changes
            self.update_listview()
    def remove_files(self):
        # Get the row indices of the selected items in the List_FIX_RAW list view
        selected_indexes = [index.row() for index in self.dockwidget.List_FIX_RAW.selectedIndexes()]
        
        # Iterate over the selected indexes in reverse order (starting from the last index)
        for index in sorted(selected_indexes, reverse=True):
            # Delete the layer at the corresponding index in the selected_layers list
            del self.selected_layers[index]
        
        # Update the list view to reflect the changes
        self.update_listview()
    def update_listview(self):
        # Create a new QStandardItemModel
        model = QStandardItemModel()

        # Iterate over each layer in the selected_layers list
        for layer in self.selected_layers:
            # Create a new QStandardItem with the base name of the layer file
            item = QStandardItem(os.path.basename(layer))
            
            # Set the item as checkable and set its initial check state to Checked
            item.setCheckable(True)
            item.setCheckState(Qt.Checked)
            
            # Append the item to the model
            model.appendRow(item)

        # Set the model as the data source for the List_FIX_RAW widget in the dockwidget
        self.dockwidget.List_FIX_RAW.setModel(model)

# DATA IMPORT
    def copy_data(self):
        # Iterate over the range of rows in the List_FIX_RAW model
        for index in range(self.dockwidget.List_FIX_RAW.model().rowCount()):
            # Get the item at the current index
            item = self.dockwidget.List_FIX_RAW.model().item(index)
            
            # Check if the item is checked
            if item.checkState() == Qt.Checked:
                # Get the selected file path
                selected_file = self.selected_layers[index]
                
                # Get the file name from the selected file path
                file_name = os.path.basename(selected_file)
                
                # Get the original folder path from the selected file path
                original_folder = os.path.dirname(selected_file)
                
                # Create the target file paths in the temporary directory
                target_shp = os.path.join(self.temp, file_name)
                target_shx = os.path.join(self.temp, os.path.splitext(file_name)[0] + ".shx")
                target_dbf = os.path.join(self.temp, os.path.splitext(file_name)[0] + ".dbf")
                
                # Check if the source files exist in the original folder
                if os.path.exists(os.path.join(original_folder, file_name)):
                    # Copy the source files to the target directory
                    shutil.copy(os.path.join(original_folder, file_name), target_shp)
                    shutil.copy(os.path.join(original_folder, os.path.splitext(file_name)[0] + ".shx"), target_shx)
                    shutil.copy(os.path.join(original_folder, os.path.splitext(file_name)[0] + ".dbf"), target_dbf)
    def add_columns_to_attribute_table(self):
        # Get a list of files in the specified directory
        files = os.listdir(self.temp)

        # Iterate over each file in the directory
        for file_name in files:
            # Check if the file has a ".shp" extension
            if file_name.lower().endswith(".shp"):
                # Create a vector layer from the shapefile
                layer = QgsVectorLayer(os.path.join(self.temp, file_name), 'shp_layer', 'ogr')

                # Check if the layer is valid
                if not layer.isValid():
                    # Display an error message and return if the layer is not valid
                    iface.messageBar().pushMessage('Error', 'An error occurred while loading shp file for adding columns', level=Qgis.Critical)
                    return

                # Start editing the layer
                layer.startEditing()

                # Add new attributes
                layer.dataProvider().addAttributes([
                    QgsField("MergeSrc",  QVariant.String),
                    QgsField("FileName", QVariant.String),
                    QgsField("PartNum",  QVariant.String),
                    QgsField("Date",     QVariant.Date)
                ])

                # Update the layer to reflect the changes
                layer.updateFields()

                # Commit the changes to the layer
                layer.commitChanges()
    def fill_src_column(self):
        # Get a list of files in the self.temp directory
        files = os.listdir(self.temp)

        # Iterate over each file in the directory
        for file_name in files:
            # Check if the file has a .shp extension (case insensitive)
            if file_name.lower().endswith(".shp"):
                # Create a QgsVectorLayer object with the file path and set the layer name to 'shp_layer'
                layer = QgsVectorLayer(os.path.join(self.temp, file_name), 'shp_layer', 'ogr')
                
                # Start editing the layer
                layer.startEditing()
                
                # Get the normalized path of the file
                merge_src_value = os.path.normpath(os.path.join(self.temp, file_name))
                
                # Get the index of the "MergeSrc" field in the layer
                merge_src_index = layer.fields().indexFromName("MergeSrc")
                
                # Check if the "MergeSrc" field exists in the layer
                if merge_src_index != -1:
                    # Get all the features in the layer
                    features = layer.getFeatures()
                    
                    # Iterate over each feature
                    for feature in features:
                        # Set the "MergeSrc" attribute of the feature to the merge_src_value
                        feature.setAttribute(merge_src_index, merge_src_value)
                        
                        # Update the feature in the layer
                        layer.updateFeature(feature)
                
                # Commit the changes made to the layer
                layer.commitChanges()
    def fill_filename_column(self):
        # Get the list of files in the specified directory
        files = os.listdir(self.temp)

        # Loop through each file
        for file_name in files:
            # Check if the file has a .shp extension
            if file_name.lower().endswith(".shp"):
                # Create a vector layer using the file
                layer = QgsVectorLayer(os.path.join(self.temp, file_name), 'shp_layer', 'ogr')

                # Start editing the layer
                layer.startEditing()

                # Get the full path of the file
                filename_value = os.path.normpath(os.path.join(self.temp, file_name))

                # Get the base name of the file without the extension and convert it to uppercase
                filename_base_name = os.path.splitext(os.path.basename(filename_value))[0]
                filename_base_name = filename_base_name.upper()

                # Get the index of the "FileName" attribute in the layer
                file_name_index = layer.fields().indexFromName("FileName")

                # Check if the "FileName" attribute exists in the layer
                if file_name_index != -1:
                    # Get all the features in the layer
                    features = layer.getFeatures()

                    # Loop through each feature
                    for feature in features:
                        # Set the value of the "FileName" attribute to the base name of the file
                        feature.setAttribute(file_name_index, filename_base_name)

                        # Update the feature in the layer
                        layer.updateFeature(feature)

                # Commit the changes made to the layer
                layer.commitChanges()
    def fill_partnum_column(self):
        # Get a list of files in the specified directory
        files = os.listdir(self.temp)

        # Iterate through each file in the directory
        for file_name in files:
            # Check if the file has a .shp extension
            if file_name.lower().endswith(".shp"):
                # Create a QgsVectorLayer object from the file
                layer = QgsVectorLayer(os.path.join(self.temp, file_name), 'shp_layer', 'ogr')
                
                # Start editing the layer
                layer.startEditing()
                
                # Get the normalized path of the file
                partnum_value = os.path.normpath(os.path.join(self.temp, file_name))
                
                # Get the base name of the file without the extension
                partnum_base_name = os.path.splitext(os.path.basename(partnum_value))[0]
                
                # Convert the base name to uppercase
                partnum_base_name = partnum_base_name.upper()
                
                # Get the index of the "FileName" field in the layer
                file_name_index = layer.fields().indexFromName("FileName")
                
                # Get the index of the "PartNum" field in the layer
                part_name_index = layer.fields().indexFromName("PartNum")
                
                # Check if both field indices are valid
                if file_name_index != -1 and part_name_index != -1:
                    # Get all the features in the layer
                    features = layer.getFeatures()
                    
                    # Iterate through each feature
                    for feature in features:
                        # Get the value of the "FileName" attribute
                        file_name_value = feature.attribute(file_name_index)
                        
                        # Split the file name at the first "_" character and get the first part
                        part_name_value = file_name_value.split("_", 1)[0]
                        
                        # Set the value of the "PartNum" attribute to the extracted part name
                        feature.setAttribute(part_name_index, part_name_value)
                        
                        # Update the feature in the layer
                        layer.updateFeature(feature)
                
                # Commit the changes made to the layer
                layer.commitChanges()
    def update_date_column(self):
        # Get a list of all files in the 'temp' directory
        files = os.listdir(self.temp)

        # Iterate through each file in the directory
        for file_name in files:
            # Check if the file has a '.shp' extension
            if file_name.lower().endswith(".shp"):
                # Create a vector layer using the file
                layer = QgsVectorLayer(os.path.join(self.temp, file_name), 'shp_layer', 'ogr')

                # Start editing the layer
                layer.startEditing()

                # Get the index of the 'Sync_time' and 'Date' fields in the layer
                sync_time_index = layer.fields().indexFromName("Sync_time")
                date_index = layer.fields().indexFromName("Date")

                # Check if both fields exist in the layer
                if sync_time_index != -1 and date_index != -1:
                    # Get all features in the layer
                    features = layer.getFeatures()

                    # Iterate through each feature
                    for feature in features:
                        # Get the value of the 'Sync_time' attribute
                        sync_time_value = feature.attribute(sync_time_index)

                        # Convert the sync_time_value to a formatted date string
                        date_value = QDateTime.fromMSecsSinceEpoch(int(sync_time_value)).toString("yyyy-MM-dd hh:mm:ss")

                        # Set the 'Date' attribute of the feature to the formatted date string
                        feature.setAttribute(date_index, date_value)

                        # Update the feature in the layer
                        layer.updateFeature(feature)

                # Commit the changes made to the layer
                layer.commitChanges()
    def merge_fix(self):
        # Get the dataset name from the GUI
        self.dataset_name = self.dockwidget.TaskDatasetName.text()

        # Set the directory to the temporary directory
        directory = self.temp

        # Get a list of all files in the directory
        fileList = os.listdir(directory)

        # Create an empty list to store features
        feats = []

        # Initialize the vector layer variable
        v_layer = None

        # Loop through each file in the directory
        for file in fileList:
            # Check if the file ends with '.shp' and contains 'fixationpoints' in the name
            if file.endswith('.shp') and 'fixationpoints' in file:
                # Get the file path
                file_path = os.path.join(directory, file)

                # Create a vector layer from the file
                layer = QgsVectorLayer(file_path, file, 'ogr')

                # Loop through each feature in the layer
                for feat in layer.getFeatures():
                    # Get the geometry and attributes of the feature
                    geom = feat.geometry()
                    attrs = feat.attributes()

                    # Create a new feature and set its geometry and attributes
                    feature = QgsFeature()
                    feature.setGeometry(geom)
                    feature.setAttributes(attrs)

                    # Add the feature to the list
                    feats.append(feature)

        # Get the CRS (Coordinate Reference System) of the layer
        crs = layer.crs().toWkt()

        # Get the field list of the layer
        field_list = layer.dataProvider().fields().toList()

        # Check the geometry type of the layer
        if layer.wkbType() == QgsWkbTypes.Point:
            # Create a new point vector layer with the same CRS
            v_layer = QgsVectorLayer('Point?crs=' + crs, 'merged_FIX_points', "memory")

        # Check if the vector layer is not None
        if v_layer is not None:
            # Get the data provider of the vector layer
            prov = v_layer.dataProvider()

            # Add the attributes to the vector layer
            prov.addAttributes(field_list)

            # Update the fields of the vector layer
            v_layer.updateFields()

            # Start editing the vector layer
            v_layer.startEditing()

            # Add the features to the vector layer
            prov.addFeatures(feats)

            # Commit the changes to the vector layer
            v_layer.commitChanges()

            # Set the CRS of the vector layer to EPSG:4326 (WGS 84)
            crs = QgsCoordinateReferenceSystem('EPSG:4326')
            v_layer.setCrs(crs)

            # Generate the output file name and path
            output_file_name = self.dataset_name + "_FIX.shp"
            output_file_path = os.path.join(self.fix_dir, output_file_name)

            # Write the vector layer as an ESRI Shapefile with UTF-8 encoding
            QgsVectorFileWriter.writeAsVectorFormat(v_layer, output_file_path, 'utf-8', crs, "ESRI Shapefile")

            # Check if the 'dataset_name' attribute exists and if it is empty
            if not hasattr(self, 'dataset_name') or len(self.dataset_name) == 0:
                # Display a warning message if the 'dataset_name' attribute is missing or empty
                QMessageBox.warning(None, "Warning", "Task dataset name was not filled in.")
    def merge_raw(self):
        # Get the dataset name from the GUI
        self.dataset_name = self.dockwidget.TaskDatasetName.text()

        # Get the directory where the files are stored
        directory = self.temp

        # Get a list of all files in the directory
        fileList = os.listdir(directory)

        # Initialize an empty list to store the features
        feats = []

        # Initialize a variable to store the vector layer
        v_layer = None

        # Iterate over each file in the file list
        for file in fileList:
            # Check if the file is a shapefile and contains 'rawpoints' in its name
            if file.endswith('.shp') and 'rawpoints' in file:
                # Get the file path
                file_path = os.path.join(directory, file)

                # Create a vector layer from the file
                layer = QgsVectorLayer(file_path, file, 'ogr')

                # Iterate over each feature in the layer
                for feat in layer.getFeatures():
                    # Get the geometry and attributes of the feature
                    geom = feat.geometry()
                    attrs = feat.attributes()

                    # Create a new feature and set its geometry and attributes
                    feature = QgsFeature()
                    feature.setGeometry(geom)
                    feature.setAttributes(attrs)

                    # Add the feature to the list of features
                    feats.append(feature)

        # Get the coordinate reference system (CRS) of the layer
        crs = layer.crs().toWkt()

        # Get the fields of the layer
        field_list = layer.dataProvider().fields().toList()

        # Check the geometry type of the layer
        if layer.wkbType() == QgsWkbTypes.Point:
            # Create a new point vector layer with the same CRS
            v_layer = QgsVectorLayer('Point?crs=' + crs, 'merged_RAW_points', "memory")

        # Check if a valid vector layer was created
        if v_layer is not None:
            # Get the data provider of the vector layer
            prov = v_layer.dataProvider()

            # Add the fields to the vector layer
            prov.addAttributes(field_list)

            # Update the fields of the vector layer
            v_layer.updateFields()

            # Start editing the vector layer
            v_layer.startEditing()

            # Add the features to the vector layer
            prov.addFeatures(feats)

            # Commit the changes to the vector layer
            v_layer.commitChanges()

            # Create a CRS object for WGS 84
            crs = QgsCoordinateReferenceSystem('EPSG:4326')

            # Set the CRS of the vector layer to WGS 84
            v_layer.setCrs(crs)

            # Define the output file name
            output_file_name = self.dataset_name + "_RAW.shp"

            # Define the output file path
            output_file_path = os.path.join(self.raw_dir, output_file_name)

            # Write the vector layer to the output file in ESRI Shapefile format
            QgsVectorFileWriter.writeAsVectorFormat(v_layer, output_file_path, 'utf-8', crs, "ESRI Shapefile")

            # Check if the 'dataset_name' attribute exists and if it is empty
            if not hasattr(self, 'dataset_name') or len(self.dataset_name) == 0:
                # Display a warning message if the 'dataset_name' attribute is missing or empty
                QMessageBox.warning(None, "Warning", "Task dataset name was not filled in.")
    def load_FIX_RAW_into_QGIS(self):
        fix_files = [file for file in os.listdir(self.fix_dir) if file.endswith(".shp") and "FIX" in file]
        raw_files = [file for file in os.listdir(self.raw_dir) if file.endswith(".shp") and "RAW" in file]
        for fix_file in fix_files:
            fix_layer_path = os.path.join(self.fix_dir, fix_file)
            fix_layer = QgsVectorLayer(fix_layer_path, fix_file, "ogr")
            if not fix_layer.isValid():
                print(f"Layer failed to load: {fix_file}")
            else:
                QgsProject.instance().addMapLayer(fix_layer)

        for raw_file in raw_files:
            raw_layer_path = os.path.join(self.raw_dir, raw_file)
            raw_layer = QgsVectorLayer(raw_layer_path, raw_file, "ogr")
            if not raw_layer.isValid():
                print(f"Layer failed to load: {raw_file}")
            else:
                QgsProject.instance().addMapLayer(raw_layer)

# CHECK
    def check_inputs(self):
        # Check if the 'dirname' attribute exists
        if not hasattr(self, 'dirname') or len(self.dirname) == 0:
            QMessageBox.warning(None, "Warning", "No directory was selected for the output files.")

        # Check if the 'selected_layers' attribute exists
        if not hasattr(self, 'selected_layers') or len(self.selected_layers) == 0:
            # Display a warning message if the 'selected_layers' attribute is missing or empty
            QMessageBox.warning(None, "Warning", "No input FIX or RAW files were selected.")

# 1) AOI
    def aoi_tab(self):
        # Check if the AOI checkbox is checked
        if self.dockwidget.checkBox_AOI.isChecked():
            print("AOI was checked. Proceeding with further actions.")
            
            # Check if the 'selected_AOI_layers' attribute exists and if it is empty
            if not hasattr(self, 'selected_AOI_layers') or len(self.selected_AOI_layers) == 0:
                # Display a warning message if the 'selected_AOI_layers' attribute is missing or empty
                QMessageBox.warning(None, "Warning", "No input AOI polygons were selected.")
            
            # Iterate over the range of rows in the List_AOI model
            for index in range(self.dockwidget.List_AOI.model().rowCount()):
                # Get the item at the current index
                item = self.dockwidget.List_AOI.model().item(index)               
                
                # Check if the item is checked
                if item.checkState() == Qt.Checked:
                    # Get the selected file path
                    selected_AOI_file = self.selected_AOI_layers[index]                   
                    
                    # Get the file name from the selected file path
                    file_name = os.path.basename(selected_AOI_file)
                    new_file_name = "AOI_copy_" + file_name                    
                    
                    # Get the original folder path from the selected file path
                    original_folder = os.path.dirname(selected_AOI_file)                  
                    
                    # Create the target file paths in the temporary directory
                    target_shp = os.path.join(self.temp, new_file_name)
                    target_shx = os.path.join(self.temp, os.path.splitext(new_file_name)[0] + ".shx")
                    target_dbf = os.path.join(self.temp, os.path.splitext(new_file_name)[0] + ".dbf")
                    
                    # Check if the source files exist in the original folder
                    if os.path.exists(os.path.join(original_folder, file_name)):
                        # Copy the source files to the target directory
                        shutil.copy(os.path.join(original_folder, file_name), target_shp)
                        shutil.copy(os.path.join(original_folder, os.path.splitext(file_name)[0] + ".shx"), target_shx)
                        shutil.copy(os.path.join(original_folder, os.path.splitext(file_name)[0] + ".dbf"), target_dbf)

            # Iterate over the files in the temporary directory
            for filename in os.listdir(self.temp):
                # Check if the file starts with "AOI_copy_" and ends with ".shp"
                if filename.startswith("AOI_copy_") and filename.endswith(".shp"):
                    filepath = os.path.join(self.temp, filename)
                    
                    # Read the file as a GeoDataFrame
                    gdf = gpd.read_file(filepath)
                    
                    # Set the coordinate reference system (CRS) of the GeoDataFrame to "EPSG:4326"
                    gdf.crs = "EPSG:4326"
                    
                    # Reproject the GeoDataFrame to "EPSG:4326"
                    gdf = gdf.to_crs("EPSG:4326")
                    
                    # Create the output file name
                    outputFilename = "WGS84_" + filename
                    outputFilePath = os.path.join(self.temp, outputFilename)
                    
                    # Save the reprojected GeoDataFrame to a file
                    gdf.to_file(outputFilePath)

            fix_files = [file for file in os.listdir(self.fix_dir) if file.endswith(".shp") and "FIX" in file]
            raw_files = [file for file in os.listdir(self.raw_dir) if file.endswith(".shp") and "RAW" in file]
            aoi_files = [file for file in os.listdir(self.temp) if file.endswith(".shp") and "WGS84_AOI" in file]

            if len(aoi_files) > 0 and len(fix_files) > 0:
                for fix_file in fix_files:
                    fix_filepath = os.path.join(self.fix_dir, fix_file)
                    fix_gdf = gpd.read_file(fix_filepath)

                    # Create AOI_X columns in the point layer for each AOI polygon
                    for i, aoi_file in enumerate(aoi_files):
                        aoi_filepath = os.path.join(self.temp, aoi_file)
                        aoi_gdf = gpd.read_file(aoi_filepath)
                        aoi_attribute = f"AOI_{i+1}"
                        # If the column does not exist yet, add it
                        if aoi_attribute not in fix_gdf.columns:
                            fix_gdf[aoi_attribute] = 0
                        
                        # Update the AOI_X column for each point based on the overlay
                        for point_idx, point in fix_gdf.iterrows():
                            if any(point['geometry'].intersects(aoi_geom) for aoi_geom in aoi_gdf.geometry):
                                fix_gdf.at[point_idx, aoi_attribute] = 1

                    # Save changes back to the point layer
                    fix_gdf.to_file(fix_filepath)

            if len(aoi_files) > 0 and len(raw_files) > 0:
                for raw_file in raw_files:
                    raw_filepath = os.path.join(self.raw_dir, raw_file)
                    raw_gdf = gpd.read_file(raw_filepath)

                    # Create AOI_X columns in the point layer for each AOI polygon
                    for i, aoi_file in enumerate(aoi_files):
                        aoi_filepath = os.path.join(self.temp, aoi_file)
                        aoi_gdf = gpd.read_file(aoi_filepath)
                        aoi_attribute = f"AOI_{i+1}"
                        if aoi_attribute not in raw_gdf.columns:
                            raw_gdf[aoi_attribute] = 0

                        # Update the AOI_X column for each point based on the overlay
                        for point_idx, point in raw_gdf.iterrows():
                            if any(point['geometry'].intersects(aoi_geom) for aoi_geom in aoi_gdf.geometry):
                                raw_gdf.at[point_idx, aoi_attribute] = 1

                    raw_gdf.to_file(raw_filepath)

            # Copy the resulting AOI files to the output directory
            if len(aoi_files) > 0:
                for aoi_file in aoi_files:
                    base_name = os.path.splitext(aoi_file)[0]
                    related_files = [file for file in os.listdir(self.temp) if file.startswith(base_name) and file.endswith(('.shp', '.shx', '.dbf', '.prj'))]
                    for file in related_files:
                        source_path = os.path.join(self.temp, file)
                        destination_path = os.path.join(self.AOI_dir, file)
                        shutil.copy(source_path, destination_path)
                    aoi_layer = QgsVectorLayer(destination_path, aoi_file, "ogr")
                    if self.dockwidget.checkBox_AOI_data.isChecked():
                        if not aoi_layer.isValid():
                            print(f"Layer failed to load: {aoi_file}")
                        else:
                            QgsProject.instance().addMapLayer(aoi_layer)
    def add_AOI_polygons(self):
        # Create a file dialog instance
        file_dialog = QFileDialog()

        # Set the file mode to allow selecting multiple existing files
        file_dialog.setFileMode(QFileDialog.ExistingFiles)

        # Set the name filter to only show Shapefile files
        file_dialog.setNameFilter("Shapefile files (*.shp)")

        # Execute the file dialog and check if it was accepted
        if file_dialog.exec_():
            # Get the list of selected files from the file dialog
            selected_AOI_files = file_dialog.selectedFiles()

            # Extend the list of selected layers with the selected files
            self.selected_AOI_layers.extend(selected_AOI_files)

            # Update the list view to reflect the changes
            self.update_AOI_listview()
    def remove_AOI_files(self):
        # Get the row indices of the selected items in the List_FIX_RAW list view
        selected_AOI_indexes = [index.row() for index in self.dockwidget.List_AOI.selectedIndexes()]
        
        # Iterate over the selected indexes in reverse order (starting from the last index)
        for index in sorted(selected_AOI_indexes, reverse=True):
            # Delete the layer at the corresponding index in the selected_AOI_layers list
            del self.selected_AOI_layers[index]
        
        # Update the list view to reflect the changes
        self.update_AOI_listview()
    def update_AOI_listview(self):
        # Create a new QStandardItemModel
        model = QStandardItemModel()

        # Iterate over each layer in the selected_AOI_layers list
        for layer in self.selected_AOI_layers:
            # Create a new QStandardItem with the base name of the layer file
            item = QStandardItem(os.path.basename(layer))
            
            # Set the item as checkable and set its initial check state to Checked
            item.setCheckable(True)
            item.setCheckState(Qt.Checked)
            
            # Append the item to the model
            model.appendRow(item)
        
        # Set the model as the data source for the List_FIX_RAW widget in the dockwidget
        self.dockwidget.List_AOI.setModel(model)
    def AOI_about(self):
        # Information message to display to the user
        message_AOI = "Area of Interest (AOI) in eye-tracking (ET) is an analytical method involving manually marking areas of interest and their interaction with collected data. Examples include map fields, legends, titles, scales, or credits. The AOI Intersect tool is essential as it records in the attribute table of point ET data the overlap with AOIs, creating new fields (e.g., AOI_1, AOI_2) to indicate presence (1) or absence (0) within an AOI. This facilitates analysis of how ET data intersects with defined AOIs.\n\nIn a QGIS software plugin, the implementation includes key functions. The aoi_tab function manages the AOI analysis process, verifying AOI polygon selection and converting them to the 'EPSG:4326' coordinate system for storage. It also analyzes FIX and RAW files, creating and updating AOI_x columns based on AOI polygon overlap.\n\nAdditional functions allow users to add or remove AOI polygons, while update_AOI_listview updates the UI to display the current state of selected AOI polygons. This tool efficiently analyzes and visualizes the relationships between ET data and AOIs, enhancing data understanding and interpretation in ET analysis. The output includes new fields in the attribute table of point ET data, indicating which AOIs intersect with specific ET data, crucial for detailed analysis and interpretation within interest areas."

        # Show the message box with the information
        QMessageBox.information(None, "About AOI", message_AOI)

# 2) AVD
    def AVD_about(self):
        # Information message to display to the user
        message_AVD = "The Attribute Visualization Duration tool facilitates the visualization of fixation durations by creating choropleth maps, highlighting areas of interest based on how long respondents focus on specific points. Utilizing the Duration attribute, it generates a new layer that distinctively represents each participant's gaze data with unique colors, enabling researchers to easily discern patterns of visual attention across different subjects or tasks."

        # Show the message box with the information
        QMessageBox.information(None, "About AVD", message_AVD)
    def AVD(self):
        if not self.dockwidget.checkBox_AVD.isChecked():
            print("AVD was not checked. No further actions.")
            return

        print("AVD was checked. Proceeding with further actions.")

        directory = self.fix_dir
        for file in os.listdir(directory):
            if file.endswith('.shp'):
                original_layer_path = os.path.join(directory, file)
                new_layer_path = os.path.join(self.AVD_dir, file.replace('.shp', '_AVD.shp'))

                # Duplicate the layer and associated files
                for ext in ['.shp', '.shx', '.dbf']:
                    original_file_path = original_layer_path.replace('.shp', ext)
                    new_file_path = new_layer_path.replace('.shp', ext)
                    shutil.copyfile(original_file_path, new_file_path)

                # Load the new layer
                layer = QgsVectorLayer(new_layer_path, 'Duration Visualization', 'ogr')

                # Get unique participants
                participants = layer.uniqueValues(layer.fields().indexFromName('PartNum'))

                def map_value_to_size(value, min_value, max_value, min_size, max_size):
                    # Map the value to a size between min_size and max_size using a logarithmic scale
                    log_min = math.log(min_value if min_value > 0 else 1)
                    log_max = math.log(max_value)
                    scale = (math.log(value if value > 0 else 1) - log_min) / (log_max - log_min)
                    return scale * (max_size - min_size) + min_size

                # Get the global minimum and maximum values of 'Duration'
                all_values = [value for participant in participants for value in layer.materialize(QgsFeatureRequest().setFilterExpression(f'"PartNum" = \'{participant}\'')).uniqueValues(layer.fields().indexOf('Duration'))]
                global_min_value, global_max_value = min(all_values), max(all_values)

                # Create a layer for each participant
                for participant in participants:
                    # Create a subset of the layer for the current participant
                    temp_layer = layer.materialize(QgsFeatureRequest().setFilterExpression(f'"PartNum" = \'{participant}\''))

                    # Create a new layer with the same fields as the original layer
                    participant_layer = QgsVectorLayer("Point?crs=epsg:4326", f'{participant}', "memory")
                    participant_layer.startEditing()
                    for field in temp_layer.fields():
                        participant_layer.addAttribute(QgsField(field.name(), field.type()))

                    # Copy the features from the temporary layer to the new layer
                    for feature in temp_layer.getFeatures():
                        participant_layer.addFeature(feature)

                    participant_layer.commitChanges()

                    # Generate a random color
                    color = QColor(random.randint(0, 255), random.randint(0, 255), random.randint(0, 255))

                    # Get unique values of the 'Duration' attribute
                    unique_values = participant_layer.uniqueValues(participant_layer.fields().indexOf('Duration'))

                    # Create a renderer for the participant layer
                    categories = []
                    for value in unique_values:
                        # Create a symbol for the participant layer
                        symbol = QgsSymbol.defaultSymbol(participant_layer.geometryType())
                        symbol.setColor(color)

                        # Map the value to a size between 1 mm and 20 mm
                        size = map_value_to_size(value, global_min_value, global_max_value, 1, 20)
                        symbol.setSize(size)

                        categories.append(QgsRendererCategory(value, symbol, str(value)))

                    renderer = QgsCategorizedSymbolRenderer('Duration', categories)

                    participant_layer.setRenderer(renderer)
                    QgsProject.instance().addMapLayer(participant_layer)

                    # Save the participant layer with EPSG:4326 coordinate system
                    participant_layer.setCrs(QgsCoordinateReferenceSystem('EPSG:4326'))
                    output_file = os.path.join(self.AVD_dir, f'{participant}.shp')
                    QgsVectorFileWriter.writeAsVectorFormat(participant_layer, output_file, 'utf-8', participant_layer.crs(), 'ESRI Shapefile')

                    # Load the saved layer into the project
                    saved_layer = QgsVectorLayer(output_file, f'{participant}', 'ogr')
                    #QgsProject.instance().addMapLayer(saved_layer)     

                # Zoom to the layer
                self.iface.mapCanvas().setExtent(layer.extent())
                self.iface.mapCanvas().refresh()

# 3) Heat map
    def Heatmap_about(self):
        # Information message to display to the user
        message_Heatmap = "The Heatmap tool is used to visualize the density of points in a given area. It is a useful tool for identifying areas of high and low concentration of points. The Heatmap tool creates a raster layer that represents the density of points in the input layer. The resulting raster layer can be used to identify areas of interest and patterns in the distribution of points."

        # Show the message box with the information
        QMessageBox.information(None, "About Heatmap", message_Heatmap)
    def Heatmap(self):
        if not self.dockwidget.checkBox_Heatmap.isChecked():
            print("Heatmap was not checked. No further actions.")
            return

        print("Heatmap was checked. Proceeding with further actions.")

        directory = self.raw_dir
        shp_files = glob.glob(os.path.join(directory, "*.shp"))  # Get all .shp files in the directory

        for shp_file in shp_files:
            point_layer = QgsVectorLayer(shp_file, "point_layer", "ogr")

            if not point_layer.isValid():
                print(f"Layer {shp_file} failed to load!")
                continue

            # Heatmap Renderer
            heatmap = QgsHeatmapRenderer()
            heatmap.setRadius(10)  # Set the radius
            heatmap.setWeightExpression('1')  # Set the weight expression

            # Set the color ramp
            col_ramp = QgsStyle().defaultStyle().colorRamp('Spectral')
            if col_ramp:
                col_ramp.invert()  # Inverting Color Ramp
                heatmap.setColorRamp(col_ramp)

                point_layer.setRenderer(heatmap)
                point_layer.setOpacity(0.5)  # Set the layer transparency to 50%
                point_layer.triggerRepaint()

                # Add the layer to the map
                QgsProject.instance().addMapLayer(point_layer)

                # Save the heatmap as a raster file
                output_file = os.path.join(self.Heatmap_dir, os.path.basename(shp_file)[:-4] + "_heatmap.tif")
                writer = QgsRasterFileWriter(output_file)
                
                # Create a raster pipe
                pipe = QgsRasterPipe()
                provider = point_layer.dataProvider()
                if isinstance(provider, QgsRasterDataProvider):
                    pipe.set(provider.clone())
                    
                    # Write the raster
                    writer.writeRaster(pipe, point_layer.width(), point_layer.height(), point_layer.extent(), point_layer.crs())
                else:
                    print(f"Provider for {shp_file} is not a QgsRasterDataProvider")

# FINAL START BUTTON
    def start(self):
        try:
            self.dockwidget.progressBar.setMaximum(100)
            
            # Check inputs
            self.check_inputs()  # Assumes this function can raise exceptions on failure
            self.dockwidget.progressBar.setValue(5)

            # Delete previous Temp directory
            #self.delete_temp_dir()
            self.dockwidget.progressBar.setValue(10)

            # Create Temp directory
            self.create_temp_dir()
            self.dockwidget.progressBar.setValue(15)

            # Create FIX directory
            self.create_fix_dir()
            self.dockwidget.progressBar.setValue(20)

            # Create RAW directory
            self.create_raw_dir()
            self.dockwidget.progressBar.setValue(25)

            # Create AOI directory
            self.create_AOI_dir()
            self.dockwidget.progressBar.setValue(35)

            # Create AVD directory
            self.create_AVD_dir()
            self.dockwidget.progressBar.setValue(40)

            # Create Heatmap directory
            self.create_Heatmap_dir()
            self.dockwidget.progressBar.setValue(45)

            # Copy data
            self.copy_data()
            self.dockwidget.progressBar.setValue(50)
            
            # Add columns to attribute table
            self.add_columns_to_attribute_table()
            self.dockwidget.progressBar.setValue(55)
            
            # Fill src column
            self.fill_src_column()
            self.dockwidget.progressBar.setValue(60)
            
            # Fill filename column
            self.fill_filename_column()
            self.dockwidget.progressBar.setValue(65)
            
            # Fill partnum column
            self.fill_partnum_column()
            self.dockwidget.progressBar.setValue(70)
            
            # Update date column
            self.update_date_column()
            self.dockwidget.progressBar.setValue(75)
            
            # Merge fix
            self.merge_fix()
            self.dockwidget.progressBar.setValue(80)
            
            # Merge raw
            self.merge_raw()
            self.dockwidget.progressBar.setValue(85)

            # Load FIX and RAW point layers into QGIS project
            self.load_FIX_RAW_into_QGIS()
            self.dockwidget.progressBar.setValue(100)

            # AOI if checked
            self.aoi_tab()

            # AVD if checked
            self.AVD()

            # Heatmap if checked
            self.Heatmap()
        
            iface.messageBar().pushMessage("Success", "Processing completed successfully.", level=Qgis.Success)
            QMessageBox.information(None, "Success", "Processing completed successfully.")
        except Exception as e:
            tb = traceback.format_exc()
            iface.messageBar().pushMessage("Error", str(e) + "\n" + str(tb), level=Qgis.Critical)
            QMessageBox.critical(None, "Error", f"An error occurred: {e}\n{tb}")
        finally:
            self.dockwidget.progressBar.setValue(0)